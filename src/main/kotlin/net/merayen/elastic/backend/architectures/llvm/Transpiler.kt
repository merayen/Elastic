package net.merayen.elastic.backend.architectures.llvm

import net.merayen.elastic.backend.analyzer.NodeProperties
import net.merayen.elastic.backend.architectures.llvm.nodes.GroupInterface
import net.merayen.elastic.backend.architectures.llvm.nodes.TranspilerNode
import net.merayen.elastic.backend.architectures.llvm.ports.PortRegistry
import net.merayen.elastic.backend.architectures.llvm.templating.CodeWriter
import net.merayen.elastic.backend.architectures.llvm.transpilercode.*
import net.merayen.elastic.backend.architectures.llvm.transpilercode.QueueComponent
import net.merayen.elastic.netlist.NetList
import kotlin.reflect.full.primaryConstructor

/**
 * Transpiles stuff to C.
 */
class Transpiler(
	private val netList: NetList,
	private val sampleRate: Int,
	private val depth: Int,
	private val frameSize: Int,
	private val threadCount: Int,
	private val voiceCount: Int = 256,
	private val debug: Boolean = false
) {
	inner class TranspilerData { // To share data with the TranspileNodes without giving direct access to us
		val debug: Boolean
			get() = this@Transpiler.debug

		val netList: NetList
			get() = this@Transpiler.netList

		val sampleRate: Int
			get() = this@Transpiler.sampleRate

		val depth: Int
			get() = this@Transpiler.depth

		val frameSize: Int
			get() = this@Transpiler.frameSize

		val voiceCount: Int
			get() = this@Transpiler.voiceCount

		val nodeProperties: NodeProperties
			get() = this@Transpiler.nodeProperties

		val nodes: Map<String, TranspilerNode>
			get() = this@Transpiler.nodes

		val groups: Map<TranspilerNode, List<TranspilerNode>>
			get() = this@Transpiler.groups
	}

	private val log = LogComponent()
	private val allocComponent = AllocComponent(log, debug)
	private val shared = TranspilerData()
	private val nodeProperties = NodeProperties(netList)
	val nodes: Map<String, TranspilerNode> = createNodes()

	private val groups: Map<TranspilerNode, List<TranspilerNode>> = getNodeChildren()


	fun transpile(): String {
		val topNodes = netList.nodes.filter { nodeProperties.getParent(it) == null }
		if (topNodes.size != 1)
			throw RuntimeException("NetList must have exact 1 top-most node. Got ${topNodes.size}")

		val top = topNodes[0]
		if (nodeProperties.getName(top) != "group")
			throw RuntimeException("Top-most node must be a group-node. Got ${nodeProperties.getName(top)}")

		for (node in nodes.values)
			node.shared = shared

		val queueCode = QueueComponent(threadCount, log, debug)
		val nodeDataComponent = NodeDataComponent(log, debug)
		val pipeCode = PipeComponent(allocComponent, log, debug)
		val workUnitsCode = WorkUnitsComponent(netList, nodes, log, debug)
		val mainCode = MainComponent(log.fprintfMutex, log, debug)

		val result = object : CodeWriter() {
			init {
				Comment("""
				Code generated by Elastic DAW.
				http://www.merayen.net/elastic
				""")

				Include("stdio.h")
				Include("stdlib.h")
				Include("stdbool.h")
				Include("math.h")
				Include("string.h")
				Include("time.h")
				Include("pthread.h")
				Include("unistd.h")
				Include("stdarg.h")
				Include("errno.h")

				Method("void", "exit_failure")

				log.writeDefinition(this)
				queueCode.writeDefinition(this)
				nodeDataComponent.writeHeaders(this)
				pipeCode.writeMethods(this)
				queueCode.writeMethods(this)
				writePortClasses(this)
				writeNodeStructs(this)
				writeNodeMethods(this)
				nodeDataComponent.writeDefinition(this, nodes)
				Method("void", "init_nodes") { writeNodeCreators(this) }
				Method("void", "destroy_nodes") { writeNodeDestroyers(this) }
				Method("void", "exit_failure") { Call("destroy_nodes"); Call("exit", "EXIT_FAILURE") }
				workUnitsCode.writeDefinition(this)
				Method("void", "init_voice") {
					nodes[top.id]!!.writeVoiceCreation(this)
				}
				Method("void", "process") {
					if (debug) log.write(this, "Processing a frame")
					Call("process_workunits")
					Call("send_outgoing_nodedata")
				}
				mainCode.create(this)
			}
		}.toString()

		val parts = result.split("@LINENUMBER@")
		val newResult = StringBuilder()
		var lineNo = 1
		for ((i,part) in parts.withIndex()) {
			newResult.append(part)
			lineNo += part.count { it == '\n' }

			if (i + 1 < parts.size) {
				newResult.append(lineNo.toString())
			}
		}

		return newResult.toString()
	}

	private fun writeNodeMethods(codeWriter: CodeWriter) {
		for ((nodeId, transpilerNode) in nodes) // Write the headers first so that they are available for all methods
			transpilerNode.nodeClass.writeHeaders(codeWriter)

		for ((nodeId, transpilerNode) in nodes) // Then write the implementation
			transpilerNode.nodeClass.writeMethods(codeWriter, allocComponent)
	}

	/**
	 * Creates transpiler nodes for current NetList.
	 */
	private fun createNodes(): Map<String, TranspilerNode> {
		val result = HashMap<String, TranspilerNode>()

		for ((index, node) in netList.nodes.withIndex()) {
			val name = nodeProperties.getName(node)
			val transpilerNodeCls = nodeRegistry[name] ?: throw RuntimeException("TranspilerNode '$name' not found")
			val transpilerNode = transpilerNodeCls.primaryConstructor!!.call(node.id, index)

			if (debug)
				transpilerNode.log = log

			transpilerNode.alloc = allocComponent
			transpilerNode.shared = shared
			transpilerNode.node = node
			result[node.id] = transpilerNode
		}

		return result
	}

	private fun getNodeChildren(): Map<TranspilerNode, List<TranspilerNode>> {
		val result = HashMap<TranspilerNode, List<TranspilerNode>>()

		for (node in nodes.values) {
			if (node is GroupInterface) {
				val children = netList.nodes.filter {
					nodeProperties.getParent(it) == node.nodeId
				}.map {
					nodes[it.id] ?: throw RuntimeException("Should not happen")
				}

				result[node] = children
			}
		}

		return result
	}

	private fun writePortClasses(codeWriter: CodeWriter) {
		for (port in PortRegistry.values()) {
			with(PortRegistry.getPortStruct(port.format, frameSize).cClass) {
				writeStruct(codeWriter)
				writeMethods(codeWriter, allocComponent)
			}
		}
	}

	private fun writeNodeStructs(codeWriter: CodeWriter) {
		for (node in nodes.values)
			node.writeStruct(codeWriter)
	}

	private fun writeNodeCreators(codeWriter: CodeWriter) {
		for (node in nodes.values)
			codeWriter.Statement("${node.instanceVariable} = ${node.nodeClass.writeMethodName("create")}()")
	}

	private fun writeNodeDestroyers(codeWriter: CodeWriter) {
		for (node in nodes.values)
			codeWriter.Call("${node.nodeClass.name}_destroy", node.instanceVariable)
	}
}
